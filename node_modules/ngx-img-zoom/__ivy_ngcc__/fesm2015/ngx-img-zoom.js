import { Injectable, Component, Renderer2, ViewChild, Input, HostListener, EventEmitter, Directive, Output, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["img"];
const _c1 = ["result"];
const _c2 = ["container"];
const _c3 = function (a0) { return { "hide": a0 }; };
class NgxImgZoomService {
    constructor() {
        this.zoomMode = 0 /* HoverZoom */;
    }
    // setZoomMode(zoomMode) {
    //   this.zoomMode = zoomMode;
    // }
    /**
     * @param {?} breakPoints
     * @return {?}
     */
    setZoomBreakPoints(breakPoints) {
        this.zoomBreakPoints = breakPoints;
    }
}
NgxImgZoomService.ɵfac = function NgxImgZoomService_Factory(t) { return new (t || NgxImgZoomService)(); };
NgxImgZoomService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgxImgZoomService, factory: NgxImgZoomService.ɵfac });
/** @nocollapse */
NgxImgZoomService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxImgZoomService, [{
        type: Injectable
    }], function () { return []; }, null); })();
if (false) {
    /** @type {?} */
    NgxImgZoomService.prototype.zoomMode;
    /** @type {?} */
    NgxImgZoomService.prototype.zoomBreakPoints;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxImgZoomComponent {
    /**
     * @param {?} renderer
     * @param {?} ngxZoomService
     */
    constructor(renderer, ngxZoomService) {
        this.renderer = renderer;
        this.ngxZoomService = ngxZoomService;
        this.hide = true;
        this._triggerAnimationIn = false;
        this.notFirstTime = false;
        this.showResult = false;
        this.zoomIndex = 0;
        this.zoomMode = this.ngxZoomService.zoomMode;
        this.enableZoom = false;
        this.zoomBreakPoints = this.ngxZoomService.zoomBreakPoints;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set imgStyle(val) {
        this._imgStyle = val;
    }
    /**
     * @return {?}
     */
    get imgStyle() {
        return this._imgStyle;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set resultStyle(val) {
        this._resultStyle = val;
    }
    /**
     * @return {?}
     */
    get resultStyle() {
        return this._resultStyle;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set lensStyle(val) {
        this._lensStyle = val;
        if (this.notFirstTime) {
            this.imageZoom();
        }
    }
    /**
     * @return {?}
     */
    get lensStyle() {
        return this._lensStyle;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onscroll(event) {
        this.hide = true;
        this.renderer.setStyle(this.lens, 'visibility', 'hidden');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onclick(event) {
        this.hide = true;
        this.renderer.setStyle(this.lens, 'visibility', 'hidden');
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set _imgSrc(val) {
        this.zoomImage = val;
        if (this.notFirstTime === true) {
            this.renderer.setStyle(this.result, 'backgroundImage', "url('" + val + "')");
        }
        this.notFirstTime = true;
        // this.renderer.setStyle(this.result, 'backgroundImage', val);
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set _zoomImage(val) {
        this.previewImage = val;
        this.showResult = false;
        /** @type {?} */
        const image = new Image();
        image.src = this.zoomImage;
        image.onload = (/**
         * @return {?}
         */
        () => {
            this.showResult = true;
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    handleZoomOutOnMouseWheelUp() {
        if (this.enableZoom) {
            if (this.zoomBreakPoints.length - 1 > this.zoomIndex) {
                this.zoomIndex++;
            }
            this.lensStyle = `height: ${this.zoomBreakPoints[this.zoomIndex].h}px; width: ${this.zoomBreakPoints[this.zoomIndex].w}px;`;
            this.imageZoom();
            this.moveLens(this.lastEventBeforeTheWheel); // Called to keep the position of the lens unchanged.
        }
    }
    /**
     * @return {?}
     */
    handleZoomInOnMouseWheelUp() {
        if (this.enableZoom) {
            if (this.zoomIndex > 0) {
                this.zoomIndex--;
            }
            this.lensStyle = `height: ${this.zoomBreakPoints[this.zoomIndex].h}px; width: ${this.zoomBreakPoints[this.zoomIndex].w}px;`;
            this.imageZoom();
            this.moveLens(this.lastEventBeforeTheWheel); // Called to keep the position of the lens unchanged.
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.img = this.imgElmRef.nativeElement;
        this.result = this.resultElmRef.nativeElement;
        this.container = this.containerElmRef.nativeElement;
        this.renderer.setAttribute(this.img, 'style', (/** @type {?} */ (this.imgStyle)));
        this.renderer.setAttribute(this.result, 'style', (/** @type {?} */ (this.resultStyle)));
        this.renderer.setAttribute(this.container, 'style', (/** @type {?} */ (this.containerStyle)));
        this.imageZoom();
        /*execute a function when someone moves the cursor over the image, or the lens:*/
        this.lensMouseMoveListener = this.renderer.listen(this.lens, 'mousemove', this.moveLens.bind(this));
        this.imgMouseMoveListener = this.renderer.listen(this.img, 'mousemove', this.moveLens.bind(this));
        /*and also for touch screens:*/
        this.imgTouchMoveListener = this.renderer.listen(this.img, 'touchmove', this.moveLens.bind(this));
        this.lensTouchMoveListener = this.renderer.listen(this.lens, 'touchmove', this.moveLens.bind(this));
        this.renderer.setStyle(this.lens, 'visibility', 'hidden');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.lensMouseMoveListener && this.lensMouseMoveListener();
        this.imgMouseMoveListener && this.imgMouseMoveListener();
        this.imgTouchMoveListener && this.imgTouchMoveListener();
        this.lensTouchMoveListener && this.lensTouchMoveListener();
    }
    /**
     * @return {?}
     */
    imageZoom() {
        /*create lens:*/
        if (!this.lens) {
            this.lens = this.renderer.createElement('DIV');
            this.renderer.addClass(this.lens, 'img-zoom-lens');
            // this.renderer.addClass(this.lens, 'cursor-crosshair');
            this.renderer.insertBefore(this.img.parentElement, this.lens, this.img);
        }
        /*insert lens:*/
        this.renderer.setAttribute(this.lens, 'style', (/** @type {?} */ (this.lensStyle)));
        /*calculate the ratio between result DIV and lens:*/
        this.cx = this.result.offsetWidth / this.lens.offsetWidth;
        this.cy = this.result.offsetHeight / this.lens.offsetHeight;
        /*set background properties for the result DIV:*/
        this.renderer.setStyle(this.result, 'backgroundImage', "url('" + this.zoomImage + "')");
        this.renderer.setStyle(this.result, 'backgroundSize', (this.img.width * this.cx) + 'px ' + (this.img.height * this.cy) + 'px');
        // this.renderer.setStyle(this.img.parentElement, 'position', 'relative')
    }
    /**
     * @param {?} e
     * @return {?}
     */
    moveLens(e) {
        this.lastEventBeforeTheWheel = e;
        /** @type {?} */
        let pos;
        /** @type {?} */
        let x;
        /** @type {?} */
        let y;
        /*prevent any other actions that may occur when moving over the image:*/
        e.preventDefault();
        /*get the cursor's x and y positions:*/
        pos = this.getCursorPos(e);
        /*calculate the position of the lens:*/
        x = pos.x - (this.lens.offsetWidth / 2);
        y = pos.y - (this.lens.offsetHeight / 2);
        /*prevent the lens from being positioned outside the image:*/
        if (x > this.img.width - this.lens.offsetWidth) {
            x = this.img.width - this.lens.offsetWidth;
        }
        else if (x < 0) {
            x = 0;
        }
        if (y > this.img.height - this.lens.offsetHeight) {
            y = this.img.height - this.lens.offsetHeight;
        }
        else if (y < 0) {
            y = 0;
        }
        this.hide = false;
        if (this.showResult) {
            this.renderer.setStyle(this.lens, 'left', x + 'px');
            this.renderer.setStyle(this.lens, 'top', y + 'px');
            /*display what the lens 'sees':*/
            this.renderer.setStyle(this.result, 'backgroundPosition', '-' + (x * this.cx) + 'px -' + (y * this.cy) + 'px');
            this.renderer.setStyle(this.lens, 'visibility', 'visible');
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    getCursorPos(e) {
        /** @type {?} */
        let a;
        /** @type {?} */
        let x = 0;
        /** @type {?} */
        let y = 0;
        e = e || window.event;
        /*get the x and y positions of the image:*/
        a = this.img.getBoundingClientRect();
        /*calculate the cursor's x and y coordinates, relative to the image:*/
        x = e.pageX - a.left;
        y = e.pageY - a.top;
        /*consider any page scrolling:*/
        x = x - window.pageXOffset;
        y = y - window.pageYOffset;
        return { x: x, y: y };
    }
    /**
     * @return {?}
     */
    handleMouseLeave() {
        this.hide = true;
        this.renderer.setStyle(this.lens, 'visibility', 'hidden');
    }
}
NgxImgZoomComponent.ɵfac = function NgxImgZoomComponent_Factory(t) { return new (t || NgxImgZoomComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NgxImgZoomService)); };
NgxImgZoomComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxImgZoomComponent, selectors: [["ngx-img-zoom"]], viewQuery: function NgxImgZoomComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
        ɵngcc0.ɵɵviewQuery(_c2, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.imgElmRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resultElmRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.containerElmRef = _t.first);
    } }, hostBindings: function NgxImgZoomComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("scroll", function NgxImgZoomComponent_scroll_HostBindingHandler($event) { return ctx.onscroll($event); }, false, ɵngcc0.ɵɵresolveWindow)("click", function NgxImgZoomComponent_click_HostBindingHandler($event) { return ctx.onclick($event.target); }, false, ɵngcc0.ɵɵresolveWindow);
    } }, inputs: { enableZoom: "enableZoom", imgStyle: "imgStyle", resultStyle: "resultStyle", lensStyle: "lensStyle", _imgSrc: ["zoomImageSrc", "_imgSrc"], _zoomImage: ["previewImageSrc", "_zoomImage"], containerStyle: "containerStyle" }, decls: 6, vars: 4, consts: [[1, "img-zoom-container"], ["container", ""], ["id", "myimage", "libMouseWheel", "", 1, "cursor-crosshair", 3, "src", "mouseleave", "mouseWheelUp", "mouseWheelDown"], ["img", ""], ["id", "myresult", 1, "img-zoom-result", 3, "ngClass"], ["result", ""]], template: function NgxImgZoomComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵelementStart(2, "img", 2, 3);
        ɵngcc0.ɵɵlistener("mouseleave", function NgxImgZoomComponent_Template_img_mouseleave_2_listener() { return ctx.handleMouseLeave(); })("mouseWheelUp", function NgxImgZoomComponent_Template_img_mouseWheelUp_2_listener() { return ctx.handleZoomInOnMouseWheelUp(); })("mouseWheelDown", function NgxImgZoomComponent_Template_img_mouseWheelDown_2_listener() { return ctx.handleZoomOutOnMouseWheelUp(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "div", 4, 5);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("src", ctx.previewImage, ɵngcc0.ɵɵsanitizeUrl);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c3, ctx.hide || !ctx.showResult));
    } }, directives: function () { return [MouseWheelDirective, ɵngcc1.NgClass]; }, styles: ["*[_ngcontent-%COMP%]{box-sizing:border-box}.img-zoom-container[_ngcontent-%COMP%]{position:absolute}.cursor-crosshair[_ngcontent-%COMP%]{cursor:crosshair}.img-zoom-lens[_ngcontent-%COMP%]{pointer-events:none;position:absolute;border:1px solid #d4d4d4;width:40px;height:40px}.img-zoom-result[_ngcontent-%COMP%]{border:1px solid #d4d4d4;width:300px;height:300px}.hide[_ngcontent-%COMP%]{visibility:hidden}"] });
/** @nocollapse */
NgxImgZoomComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: NgxImgZoomService }
];
NgxImgZoomComponent.propDecorators = {
    imgElmRef: [{ type: ViewChild, args: ['img', { static: false },] }],
    resultElmRef: [{ type: ViewChild, args: ['result', { static: false },] }],
    containerElmRef: [{ type: ViewChild, args: ['container', { static: false },] }],
    enableZoom: [{ type: Input }],
    imgStyle: [{ type: Input }],
    resultStyle: [{ type: Input }],
    lensStyle: [{ type: Input }],
    containerStyle: [{ type: Input }],
    onscroll: [{ type: HostListener, args: ['window:scroll', ['$event'],] }],
    onclick: [{ type: HostListener, args: ['window:click', ['$event.target'],] }],
    _imgSrc: [{ type: Input, args: ['zoomImageSrc',] }],
    _zoomImage: [{ type: Input, args: ['previewImageSrc',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxImgZoomComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-img-zoom',
                template: "\n<div  class=\"img-zoom-container\" #container>\n    <img id=\"myimage\" class='cursor-crosshair' [src]=\"previewImage\" #img (mouseleave)=\"handleMouseLeave()\" \n\tlibMouseWheel (mouseWheelUp)=\"handleZoomInOnMouseWheelUp()\" (mouseWheelDown)=\"handleZoomOutOnMouseWheelUp()\">\n\n    <div [ngClass]=\"{'hide': hide || !showResult}\" \n        id=\"myresult\" \n        class=\"img-zoom-result\" \n        #result>\n    </div>\n</div>  ",
                styles: ["*{box-sizing:border-box}.img-zoom-container{position:absolute}.cursor-crosshair{cursor:crosshair}.img-zoom-lens{pointer-events:none;position:absolute;border:1px solid #d4d4d4;width:40px;height:40px}.img-zoom-result{border:1px solid #d4d4d4;width:300px;height:300px}.hide{visibility:hidden}"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: NgxImgZoomService }]; }, { enableZoom: [{
            type: Input
        }], imgStyle: [{
            type: Input
        }], resultStyle: [{
            type: Input
        }], lensStyle: [{
            type: Input
        }], 
    /**
     * @param {?} event
     * @return {?}
     */
    onscroll: [{
            type: HostListener,
            args: ['window:scroll', ['$event']]
        }], 
    /**
     * @param {?} event
     * @return {?}
     */
    onclick: [{
            type: HostListener,
            args: ['window:click', ['$event.target']]
        }], _imgSrc: [{
            type: Input,
            args: ['zoomImageSrc']
        }], _zoomImage: [{
            type: Input,
            args: ['previewImageSrc']
        }], imgElmRef: [{
            type: ViewChild,
            args: ['img', { static: false }]
        }], resultElmRef: [{
            type: ViewChild,
            args: ['result', { static: false }]
        }], containerElmRef: [{
            type: ViewChild,
            args: ['container', { static: false }]
        }], containerStyle: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    NgxImgZoomComponent.prototype.img;
    /** @type {?} */
    NgxImgZoomComponent.prototype.lens;
    /** @type {?} */
    NgxImgZoomComponent.prototype.result;
    /** @type {?} */
    NgxImgZoomComponent.prototype.cx;
    /** @type {?} */
    NgxImgZoomComponent.prototype.cy;
    /** @type {?} */
    NgxImgZoomComponent.prototype.container;
    /** @type {?} */
    NgxImgZoomComponent.prototype.hide;
    /** @type {?} */
    NgxImgZoomComponent.prototype._triggerAnimationIn;
    /** @type {?} */
    NgxImgZoomComponent.prototype.notFirstTime;
    /** @type {?} */
    NgxImgZoomComponent.prototype.showResult;
    /** @type {?} */
    NgxImgZoomComponent.prototype.lastEventBeforeTheWheel;
    /** @type {?} */
    NgxImgZoomComponent.prototype.zoomBreakPoints;
    /** @type {?} */
    NgxImgZoomComponent.prototype.zoomIndex;
    /** @type {?} */
    NgxImgZoomComponent.prototype.lensMouseMoveListener;
    /** @type {?} */
    NgxImgZoomComponent.prototype.imgMouseMoveListener;
    /** @type {?} */
    NgxImgZoomComponent.prototype.imgTouchMoveListener;
    /** @type {?} */
    NgxImgZoomComponent.prototype.lensTouchMoveListener;
    /** @type {?} */
    NgxImgZoomComponent.prototype.zoomMode;
    /** @type {?} */
    NgxImgZoomComponent.prototype.imgElmRef;
    /** @type {?} */
    NgxImgZoomComponent.prototype.resultElmRef;
    /** @type {?} */
    NgxImgZoomComponent.prototype.containerElmRef;
    /** @type {?} */
    NgxImgZoomComponent.prototype.enableZoom;
    /** @type {?} */
    NgxImgZoomComponent.prototype._imgStyle;
    /** @type {?} */
    NgxImgZoomComponent.prototype._resultStyle;
    /** @type {?} */
    NgxImgZoomComponent.prototype._lensStyle;
    /** @type {?} */
    NgxImgZoomComponent.prototype.containerStyle;
    /** @type {?} */
    NgxImgZoomComponent.prototype.zoomImage;
    /** @type {?} */
    NgxImgZoomComponent.prototype.previewImage;
    /**
     * @type {?}
     * @private
     */
    NgxImgZoomComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    NgxImgZoomComponent.prototype.ngxZoomService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MouseWheelDirective {
    constructor() {
        this.mouseWheelUp = new EventEmitter();
        this.mouseWheelDown = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseWheelChrome(event) {
        this.mouseWheelFunc(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseWheelFirefox(event) {
        this.mouseWheelFunc(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseWheelIE(event) {
        this.mouseWheelFunc(event);
    }
    /**
     * @param {?} events
     * @return {?}
     */
    mouseWheelFunc(events) {
        // tslint:disable-next-line: deprecation
        /** @type {?} */
        const event = window.event || events;
        // old IE support
        /** @type {?} */
        const delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));
        if (delta > 0) {
            this.mouseWheelUp.emit(event);
        }
        else if (delta < 0) {
            this.mouseWheelDown.emit(event);
        }
        // for IE
        event.returnValue = false;
        // for Chrome and Firefox
        if (event.preventDefault) {
            event.preventDefault();
        }
    }
}
MouseWheelDirective.ɵfac = function MouseWheelDirective_Factory(t) { return new (t || MouseWheelDirective)(); };
MouseWheelDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MouseWheelDirective, selectors: [["", "libMouseWheel", ""]], hostBindings: function MouseWheelDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousewheel", function MouseWheelDirective_mousewheel_HostBindingHandler($event) { return ctx.onMouseWheelChrome($event); })("DOMMouseScroll", function MouseWheelDirective_DOMMouseScroll_HostBindingHandler($event) { return ctx.onMouseWheelFirefox($event); })("onmousewheel", function MouseWheelDirective_onmousewheel_HostBindingHandler($event) { return ctx.onMouseWheelIE($event); });
    } }, outputs: { mouseWheelUp: "mouseWheelUp", mouseWheelDown: "mouseWheelDown" } });
MouseWheelDirective.propDecorators = {
    mouseWheelUp: [{ type: Output }],
    mouseWheelDown: [{ type: Output }],
    onMouseWheelChrome: [{ type: HostListener, args: ['mousewheel', ['$event'],] }],
    onMouseWheelFirefox: [{ type: HostListener, args: ['DOMMouseScroll', ['$event'],] }],
    onMouseWheelIE: [{ type: HostListener, args: ['onmousewheel', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MouseWheelDirective, [{
        type: Directive,
        args: [{
                selector: '[libMouseWheel]'
            }]
    }], function () { return []; }, { mouseWheelUp: [{
            type: Output
        }], mouseWheelDown: [{
            type: Output
        }], 
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseWheelChrome: [{
            type: HostListener,
            args: ['mousewheel', ['$event']]
        }], 
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseWheelFirefox: [{
            type: HostListener,
            args: ['DOMMouseScroll', ['$event']]
        }], 
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseWheelIE: [{
            type: HostListener,
            args: ['onmousewheel', ['$event']]
        }] }); })();
if (false) {
    /** @type {?} */
    MouseWheelDirective.prototype.mouseWheelUp;
    /** @type {?} */
    MouseWheelDirective.prototype.mouseWheelDown;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxImgZoomModule {
}
NgxImgZoomModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxImgZoomModule });
NgxImgZoomModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxImgZoomModule_Factory(t) { return new (t || NgxImgZoomModule)(); }, providers: [NgxImgZoomService], imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxImgZoomModule, { declarations: function () { return [NgxImgZoomComponent, MouseWheelDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NgxImgZoomComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxImgZoomModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                providers: [NgxImgZoomService],
                declarations: [NgxImgZoomComponent, MouseWheelDirective],
                exports: [NgxImgZoomComponent]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const NgxImgZoomMode = {
    HoverZoom: 0,
    DoubleClickZoom: 1,
    SingleClickZoom: 2,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxImgZoomComponent, NgxImgZoomModule, NgxImgZoomService, MouseWheelDirective as ɵa };

//# sourceMappingURL=ngx-img-zoom.js.map